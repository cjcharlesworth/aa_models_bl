---
title: "Branch Length Summary Stats Analysis"
output: 
  prettydoc::html_pretty:
    theme: "cayman"
params: 
  mini: TRUE
  mini_n: 30
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, echo= TRUE, include = TRUE)
library(tidyverse)
library(cowplot)
library(gt)
library(patchwork)
source("utils.R")
path_to_data <- "./" 
```

## Goal
The primary goal of this analysis is to determine whether branch length summary statistics differ across protein models.

## First let's take a look at some sample id's from the bird, enzyme, and mammal data.

```{r read in the data and make smaller datasets, message=FALSE}


birds_file <- file.path(path_to_data, "bird_empirical_branch_lengths.csv")
mammals_file <- file.path(path_to_data, "mammal_empirical_branch_lengths.csv")
enzymes_file <- file.path(path_to_data, "enzyme_empirical_branch_lengths.csv")


birds   <- read_csv(birds_file) %>% mutate(dataset =  "birds", id = as.character(id)) #might as well mutate here so we can bind rows later 
mammals <- read_csv(mammals_file) %>% mutate(dataset =  "mammals", id = as.character(id))
enzymes <- read_csv(enzymes_file) %>% mutate(dataset =  "enzymes", id = as.character(id))

# Downsample for mini analysis only
minify <- function(df) 
{
  df %>%
    group_by(id) %>% 
    nest() %>% #condense each id into its own tibble-like thing 
    ungroup() %>%
    slice(1:params$mini_n) %>% #this takes the first *however many* rows from the dataset. The *however many* is specified by the params$mini_n
    unnest(cols = c(data))
}

if (params$mini == TRUE) #if we want to use the mini versions of the datasets, then use the mini function on each of them!!
{
  minify(birds) -> birds 
  minify(enzymes) -> enzymes
  minify(mammals) -> mammals
}


summarize_branch_lengths(birds) -> birds_bl #produce a bl dataframe for all three datasets 
summarize_branch_lengths(mammals) -> mammals_bl 
summarize_branch_lengths(enzymes) -> enzymes_bl

bind_rows(mammals, enzymes, birds) -> full_data #this is just one big data frame consisting of the three datasets


summarize_branch_lengths(full_data) -> summarized_bl #this data frame will have branch length summary statistics for enzymes, birds, and mammals

print(summarized_bl) 
```
This dataset contains branch length summary statistics (columns) for a number of selected id's from the bird, mammal, and enzyme datasets. Moving forward, we will use this dataset to determine if these summary statistics differ across protein models (JTT, WAG, FLU, Poisson, and LG). 

## Analysis of Branchlength Differences Between Models 
Okay, now that we have our mini-dataset, let's begin to see how the branch length summary stats look! We will begin with some violin plots of treelength, max branch length, and mean branch length. Analysis of the results comes after the three plots. 

```{r violin function for bl measurements}

Violin_bl_measurements<-function(bl_df, measurement, y_axis_title, plot_title)
{
  bl_df%>%
  mutate(ASRV_modified= if_else(ASRV==TRUE, "ASRV +", "ASRV -"))%>% #need to make it non-logistic
  select({{measurement}}, model, id, ASRV_modified, dataset)%>%
  group_by(model, id, dataset, ASRV_modified)%>% #need to group before modeling
  ggplot(aes(x=model, y={{measurement}}, fill=model))+ #want measurment over model
  geom_violin()+
  geom_point()+ #having both geoms will be nice
  stat_summary()+
  facet_wrap(vars(ASRV_modified))+ #want with and without asrv 
  scale_fill_brewer(palette = "Dark2")+
  labs(x="Model", y=y_axis_title, title=plot_title)
}

```

```{r vizualize branch lengths violin}
#create violin plots for treelength, max_bl, and mean_bl
Violin_bl_measurements(summarized_bl, treelength, "Treelength", "Estimated Treelengths for Selected Id's")->violin_treelength
Violin_bl_measurements(summarized_bl, mean_bl, "Mean_bl", "Estimated Mean Branchlengths for Selected Id's")->violin_mean_bl
Violin_bl_measurements(summarized_bl, max_bl, "Max_bl", "Estimated Maximum Branchlengths for Selected Id's")->violin_max_bl
```

```{r actually show violins, out.height=200, out.width=200}
#patchwork AND cowplot were giving me a ROUGH time, outputs were always cut off...even after adjusting output heights and widths.
(violin_treelength)
(violin_mean_bl)
(violin_max_bl)
```
<br><br>
From this, we first see that FLU *appears* to overestimate the branch length related measurements while Poisson underestimates. The next noticable aspect of these figures is that these distributions appear to be bi-modal. In each of the violins, there are points grouped both at the top and bottom, but why? Since all other factors have been accounted for, including ASRV, there must be a difference in the *datasets themselves* that is causing us to see this bimodal distribution. A quick look at the `summarized_bl` dataset in the beginning of this document supports our suspicion, as the `enzymes` summary statistics are elevated compared to those of `birds` or `mammals`. Therefore, the points grouped towards the top of each violin are estimates from the `enzymes` dataset. The next aspect of these figures that needs to be addressed is the noticeable difference in `ASRV +` and `ASRV-` plots. Remember that ASRV is ["among-site rate variation" and allows for each site in a sequence to have a different probability of having a replacement/substitution](http://nsmn1.uh.edu/dgraur/ArticlesPDFs/BioInfo_Branch&Bound.pdf). Therefore, it is expected that `ASRV+` plots display more evolutionary change since sites are likely to mutate at different rates due do differing evolutionary pressures. Overall, this analysis suggests that it may be interesting to run the summary statistics without the enzyme data, to see how the models perform under lower-variance conditions. Maybe the overestimation by FLU and the underestimation by Poisson are due to the high variation alone, in which case we could approximate *how much* variance these models can "handle" before they are no longer reliable. 
<br><br>

### Now, Let's continue to address our goal, but this time by utilizing linear models to determine if branch length *summary statistics* do indeed differ across protein models. Specifically, we will look at mean branch length, treelength, and max branch length.

First, let's see the function that will be used to conduct this analysis:
``` {r, bl_lm function with gt chart}

#linear model with three different types, each with different predictors. Once a lm is performed, do an aov and tukey test for significance and report the results as a table where the models will be compared. Significant p values shown in red. The three arguments for this function are the branch length dataframe to be used, the type of model to run, and which summary statistic to run the model on. 
bl_lm_chart<- function (input_branchlength_df, model_type, dependent_variable_column)
{
  input_branchlength_df %>%
    mutate(ASRV_modified= if_else(ASRV==TRUE, "Yes", "No")) -> df_for_modeling

if(model_type == "type_1") #most amount of predictors 
  {
  lm({{dependent_variable_column}} ~ model+ dataset+ ASRV_modified, data= df_for_modeling)%>% aov() %>%
    TukeyHSD()->fitted_model
} 
  
else if (model_type == "type_2") #one less predictor than type 1
{
  lm({{dependent_variable_column}} ~ model+ ASRV_modified, data= df_for_modeling) %>% aov() %>%
    TukeyHSD()->fitted_model
} 
else if (model_type == "type_3") #only model is the predictor
{
  lm({{dependent_variable_column}} ~ model, data= df_for_modeling) %>% aov() %>%
    TukeyHSD()->fitted_model
}

{
fitted_model$model %>% 
    as_tibble(rownames = "comparison")-> Chart_output_wide #this makes the output nicer to read/understand
}

{
  gt(Chart_output_wide)%>% #the outputs were a little ugly, so put them right into gt chart!!
    tab_header(title="Tukey Comparisons of Models' Estimates of Branch Length Summary Statistics ", subtitle= "Significant P values highlighted in red")%>%
    fmt_number(columns="p adj", decimals=3)%>% #No scientific notation, please and thanks!!
  data_color(columns = vars("p adj"),colors = scales::col_numeric(palette = c( "red","grey"),  domain = c(0.00, 0.05)))
  
}}
```
#### We also want to plot the comparisons with geom line_range so there is a plot to accompany each table.
```{r, bl_lm2 line range plot function}
#This function is identical to the bl_lm_chart function,but includes some different wrangling so that an appropriate geom_linerange plot can be constructed. The goal WAS to have both bl_lm functions (both chart AND plot) as one large function with two distinct outputs, but unfortunately the chart outputs were not being printed correctly along with the corresponding plots. 

bl_lm_plot<- function (input_branchlength_df, model_type, dependent_variable_column)
{
  input_branchlength_df %>%
    mutate(ASRV_modified= if_else(ASRV==TRUE, "Yes", "No")) -> df_for_modeling

if(model_type == "type_1") #most amount of predictors 
  {
  lm({{dependent_variable_column}} ~ model+ dataset+ ASRV_modified, data= df_for_modeling)%>% aov() %>%
    TukeyHSD()->fitted_model
} 
  
else if (model_type == "type_2") #one less predictor than type 1
{
  lm({{dependent_variable_column}} ~ model+ ASRV_modified, data= df_for_modeling) %>% aov() %>%
    TukeyHSD()->fitted_model
} 
else if (model_type == "type_3") #only model is the predictor
{
  lm({{dependent_variable_column}} ~ model, data= df_for_modeling) %>% aov() %>%
    TukeyHSD()->fitted_model
}

{
fitted_model$model %>% 
    as_tibble(rownames = "comparison")-> Chart_output_wide #this makes the output nicer to read/understand
}

#need to pivot in order to get coefficients, lwr, upr all in the same tibble!!!!!
{
  Chart_output_wide%>%
    pivot_longer(lwr:upr, names_to ="Type_of_coeff", values_to = "Coefficients")->Chart_output_long
  
left_join(Chart_output_long, Chart_output_wide)->Chart_output_longandwide #NOW we can start graphing since we have all the columns we need!! (lwr, upr, and coefficients!!)
  
  
  ggplot((Chart_output_longandwide), aes(x=Coefficients,y=comparison))+ #want comparisons lined up along thy y axis with coefficients along the x
    geom_point()+ #this will show the upper and lower values of the confidence interval as points
    geom_linerange(xmin= Chart_output_longandwide$lwr, xmax=Chart_output_longandwide$upr)+ #this wiol connect those points with a horizontal line
    geom_vline(xintercept=0)+#this will allow us to quickly decide if the confidence interval contains 0 or not. 
    theme_classic()+
    labs(title="Linerange Plots for Tukey Comparisions Between Models", subtitle= "Significant Results Represented By Lines That Do Not Cross x=0", x="Coefficients", y="Comparisons")
}}
    

```

Now, there is LOTS of variation we are able to utilize with this function. First, we can plug in different branch length-related summary stats (`mean_bl`, `max_bl`, or `treelength`) into the `dependent_variable_column` variable in the function. Similarly, we can plug in different branch length datasets by changing the variable for `input_branchlength_df`. Note that we can also change the *predictors* that are used within the model itself. For example, one possibility is `summary stat`~`model`+ `dataset`+`ASRV_modified`. This format is basically asking the question "how well do three factors: the model used (1), the dataset the branch lengths came from (2) and the ASRV (3) explain the variation that is seen in the summary stat of interest? There are two other types of linear models that we can run from modifying this formula. They are as follows: `summary stat`~`model`+ `dataset` and `summary stat`~`model`. We can consider these three formats of linear models as three "types" of models, each with different predictor variables. For our analysis, we will conduct (9) linear models for *each* summary statistic of interest (`mean_bl`, `treelength`, and `max_bl`). There will be only one "type one" linear model for each summary statistic since the this type of model relies on there being variation in the `dataset` variable, which is only found in the `summarized bl` dataset. There will then be four (4) type 2 and four (4) type three linear models carried out for *each* statistic (one each from `birds_bl`, `mammals_bl`, `enzymes_bl`, and `summarized_bl`).Overall, this leaves us with one type 1 model, four type 2 models, and four type 3 models for each summary stat of interest. Since we are concerned with three summary stats total, this leaves us with 27 linear models to analyze! 
<br><br>

 
 First, we will look at mean branch length as our branch length summary statistic of interest. A detailed analysis of the model outputs can be found after all plots and charts are shown. 

#### Mean Branch Length
``` {r lm for mean bl}
#CAN NOT DO TYPE ONE ON THE MAMMALS, ENZYMES, OR BIRDS ALONE SINCE THERE IS NO VARIATION IN THE *DATASET* VARIABLE!!!

#As explained above, there will be one type 1, four type 2, and four type 3 linear models run for the mean_bl summary statistic. Both a plot and chart will be visible for EACH lm performed. 
bl_lm_chart(summarized_bl, "type_1", summarized_bl$mean_bl)
bl_lm_plot (summarized_bl, "type_1", summarized_bl$mean_bl)
bl_lm_chart (summarized_bl, "type_2", summarized_bl$mean_bl)
bl_lm_plot  (summarized_bl, "type_2", summarized_bl$mean_bl)
bl_lm_chart (summarized_bl, "type_3", summarized_bl$mean_bl)
bl_lm_plot (summarized_bl, "type_3", summarized_bl$mean_bl)

bl_lm_chart  (birds_bl, "type_2", birds_bl$mean_bl)
bl_lm_plot  (birds_bl, "type_2", birds_bl$mean_bl)
bl_lm_chart  (birds_bl, "type_3", birds_bl$mean_bl)
bl_lm_plot (birds_bl, "type_3", birds_bl$mean_bl)

bl_lm_chart  (mammals_bl, "type_2", mammals_bl$mean_bl)
bl_lm_plot (mammals_bl, "type_2", mammals_bl$mean_bl)
bl_lm_chart  (mammals_bl, "type_3", mammals_bl$mean_bl)
bl_lm_plot  (mammals_bl, "type_3", mammals_bl$mean_bl)

bl_lm_chart (enzymes_bl, "type_2", enzymes_bl$mean_bl)
bl_lm_plot (enzymes_bl, "type_2", enzymes_bl$mean_bl)
bl_lm_chart (enzymes_bl, "type_3", enzymes_bl$mean_bl)
bl_lm_plot (enzymes_bl, "type_3", enzymes_bl$mean_bl)


```

#### Treelength
Next, we will look at treelength as our brnach length summary statistic of interest.
```{r lm for treelength}
#CAN NOT DO TYPE ONE ON THE MAMMALS, ENZYMES, OR BIRDS ALONE SINCE THERE IS NO VARIATION IN THE *DATASET* VARIABLE!!!

#As explained above, there will be one type 1, four type 2, and four type 3 linear models run for the treelength summary statistic.
bl_lm_chart(summarized_bl, "type_1", summarized_bl$treelength)
bl_lm_plot (summarized_bl, "type_1", summarized_bl$treelength)
bl_lm_chart (summarized_bl, "type_2", summarized_bl$treelength)
bl_lm_plot  (summarized_bl, "type_2", summarized_bl$treelength)
bl_lm_chart (summarized_bl, "type_3", summarized_bl$treelength)
bl_lm_plot (summarized_bl, "type_3", summarized_bl$treelength)

bl_lm_chart  (birds_bl, "type_2", birds_bl$treelength)
bl_lm_plot  (birds_bl, "type_2", birds_bl$treelength)
bl_lm_chart  (birds_bl, "type_3", birds_bl$treelength)
bl_lm_plot (birds_bl, "type_3", birds_bl$treelength)

bl_lm_chart  (mammals_bl, "type_2", mammals_bl$treelength)
bl_lm_plot (mammals_bl, "type_2", mammals_bl$treelength)
bl_lm_chart  (mammals_bl, "type_3", mammals_bl$treelength)
bl_lm_plot  (mammals_bl, "type_3", mammals_bl$treelength)

bl_lm_chart (enzymes_bl, "type_2", enzymes_bl$treelength)
bl_lm_plot (enzymes_bl, "type_2", enzymes_bl$treelength)
bl_lm_chart (enzymes_bl, "type_3", enzymes_bl$treelength)
bl_lm_plot (enzymes_bl, "type_3", enzymes_bl$treelength)

```


#### Max Branch Length
Finally, we will look at max branch length as our summary statistic of interest. 
```{r lm for max_bl}
#CAN NOT DO TYPE ONE MODEL ON THE MAMMALS, ENZYMES, OR BIRDS ALONE SINCE THERE IS NO VARIATION IN THE *DATASET* VARIABLE!!!

#As explained above, there will be one type 1, four type 2, and four type 3 linear models run for the treelength summary statistic, each with a chart and plot.
bl_lm_chart(summarized_bl, "type_1", summarized_bl$max_bl)
bl_lm_plot (summarized_bl, "type_1", summarized_bl$max_bl)
bl_lm_chart (summarized_bl, "type_2", summarized_bl$max_bl)
bl_lm_plot  (summarized_bl, "type_2", summarized_bl$max_bl)
bl_lm_chart (summarized_bl, "type_3", summarized_bl$max_bl)
bl_lm_plot (summarized_bl, "type_3", summarized_bl$max_bl)

bl_lm_chart  (birds_bl, "type_2", birds_bl$max_bl)
bl_lm_plot  (birds_bl, "type_2", birds_bl$max_bl)
bl_lm_chart  (birds_bl, "type_3", birds_bl$max_bl)
bl_lm_plot (birds_bl, "type_3", birds_bl$max_bl)

bl_lm_chart  (mammals_bl, "type_2", mammals_bl$max_bl)
bl_lm_plot (mammals_bl, "type_2", mammals_bl$max_bl)
bl_lm_chart  (mammals_bl, "type_3", mammals_bl$max_bl)
bl_lm_plot  (mammals_bl, "type_3", mammals_bl$max_bl)

bl_lm_chart (enzymes_bl, "type_2", enzymes_bl$max_bl)
bl_lm_plot (enzymes_bl, "type_2", enzymes_bl$max_bl)
bl_lm_chart (enzymes_bl, "type_3", enzymes_bl$max_bl)
bl_lm_plot (enzymes_bl, "type_3", enzymes_bl$max_bl)



```

<br><br>

#### What Did We Learn from all of that modeling?
Before we begin to analyze any of the linear models constructed above, it is vital to understand that these results were obtained from small *slices* of the From this, we see that the many significant findings occur when comparing Poisson to FLU, which is not surprising when considering our earlier results seen in the violin plots. Clearly, these two models produce statistically significant differences in their predictions of branch length summary statistics. When focusing on model type, most of the significant findings occur when performing type 1 models, which have the most predictor variables of any model type (`model`, `dataset`, and `ASRV_modified` are all predictors). When considering datasets, most of the significant findings occur within the enzymes dataset, which we know is the highest-divergence dataset of the three. This suggests that higher-divergence sequences lead to more exaggerated differences in the models' estimates of branch length summary statistics. Finally, when considering the summary statistics themselves, it appears that the models' estimates of max branch length (`max_bl`) actually displayed the most discrepancy. When taking this all in as a whole, the conditions that produced the least amount of agreement between models' estimates were max_bl estimates from the enzymes dataset. This information helps us understand what conditions cause the branch length summary statistics to differ between models.

### BRIEF Analysis of Datasets
Thus far, we have really only focused on the differences that exist in branch length estimates between models, but what differences exist between the datasets themselves?

```{r, vizualize differnces in datasets}

summarized_bl%>%
  select(dataset, treelength, mean_bl, max_bl)%>%
  group_by(dataset)%>%
summarize(avg_treelength=mean(treelength), avg_bl=mean(mean_bl), avg_max_bl=mean(max_bl)) #show averages of treelength, mean branch length, and max branch length for each of the three datasets in order to look for trends. 




#perform the same wrangling as above and create a plot to display the output. 
summarized_bl%>%
  select(dataset, treelength, mean_bl, max_bl)%>%
  group_by(dataset)%>% #care about dataset here, not model
summarize(avg_treelength=mean(treelength), avg_bl=mean(mean_bl), avg_max_bl=mean(max_bl))%>%
  ggplot(aes(x=dataset, y=avg_max_bl, fill=dataset))+
  geom_col()+ #allows for quick comparison of the average summary statistics between datasets
theme_classic()+
  labs(title="Differences in Max Branch length Estimates Between Datasets", x="Dataset", y="Average Max Branchlength")+
  scale_fill_brewer(palette = "Dark2")

```
<br><br>
This quick analysis shows us that the enzymes dataset displays MUCH MORE evolutionary change than the other two datasets (at least for the selected id's). An interesting question this brings up is *why* does the enzyme data show so much more evolutionary change than the other two datasets? It could be that the sequences of the selected enzymes are not highly conserved, so they are able to change more throughout time without losing key functions. This is just one possibility of many, though. 

